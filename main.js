/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YandexTrackerLinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  trackerBaseURL: "https://tracker.yandex.ru/",
  apiToken: "",
  orgId: "",
  defaultDescription: `{% cut "\u0421\u043E\u0437\u0434\u0430\u043D\u043E \u0438\u0437 Obsidian" %}

\u042D\u0442\u0430 \u0437\u0430\u0434\u0430\u0447\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0430 \u0438\u0437 \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u0432 Obsidian.

{% endcut %}`,
  defaultAssignees: []
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app, summary, queueKey, plugin) {
    super(app);
    this.summary = summary;
    this.queueKey = queueKey;
    this.plugin = plugin;
    this.result = new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create Yandex Tracker Task?" });
    const summaryContainer = contentEl.createDiv();
    summaryContainer.createEl("p", { text: "Summary:" });
    this.summaryInput = summaryContainer.createEl("input", {
      type: "text",
      value: this.summary
    });
    this.summaryInput.style.width = "100%";
    this.summaryInput.style.marginBottom = "1em";
    const descriptionContainer = contentEl.createDiv();
    descriptionContainer.createEl("p", { text: "Description (markdown):" });
    this.descriptionInput = descriptionContainer.createEl("textarea");
    this.descriptionInput.value = this.plugin.settings.defaultDescription;
    this.descriptionInput.style.width = "100%";
    this.descriptionInput.style.height = "100px";
    this.descriptionInput.style.marginBottom = "1em";
    const deadlineContainer = contentEl.createDiv();
    deadlineContainer.createEl("p", { text: "Deadline:" });
    this.deadlineInput = deadlineContainer.createEl("input", {
      type: "date"
    });
    this.deadlineInput.style.width = "100%";
    this.deadlineInput.style.marginBottom = "1em";
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    this.deadlineInput.value = tomorrow.toISOString().split("T")[0];
    const tagsContainer = contentEl.createDiv();
    tagsContainer.createEl("p", { text: "Tags (comma-separated):" });
    this.tagsInput = tagsContainer.createEl("input", {
      type: "text",
      placeholder: "tag1, tag2, tag3"
    });
    this.tagsInput.style.width = "100%";
    this.tagsInput.style.marginBottom = "1em";
    const assigneeContainer = contentEl.createDiv();
    assigneeContainer.createEl("p", { text: "Assignee:" });
    const assigneeWrapper = assigneeContainer.createDiv();
    assigneeWrapper.style.display = "flex";
    assigneeWrapper.style.gap = "10px";
    assigneeWrapper.style.marginBottom = "1em";
    this.assigneeInput = assigneeWrapper.createEl("input", {
      type: "text",
      placeholder: "Username"
    });
    this.assigneeInput.style.flex = "1";
    for (const assignee of this.plugin.settings.defaultAssignees) {
      const assigneeButton = assigneeWrapper.createEl("button", {
        text: assignee,
        cls: "mod-cta"
      });
      assigneeButton.onclick = () => {
        this.assigneeInput.value = assignee;
      };
    }
    contentEl.createEl("p", { text: `Queue: ${this.queueKey}` });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => {
      this.resolvePromise({
        confirmed: false,
        summary: this.summary,
        description: "",
        deadline: "",
        tags: [],
        assignee: ""
      });
      this.close();
    };
    buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" }).onclick = () => {
      this.resolvePromise({
        confirmed: true,
        summary: this.summaryInput.value.trim(),
        description: this.descriptionInput.value.trim(),
        deadline: this.deadlineInput.value,
        tags: this.tagsInput.value.split(",").map((tag) => tag.trim()).filter((tag) => tag),
        assignee: this.assigneeInput.value.trim()
      });
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    if (this.resolvePromise) {
      this.resolvePromise({
        confirmed: false,
        summary: this.summary,
        description: "",
        deadline: "",
        tags: [],
        assignee: ""
      });
    }
    contentEl.empty();
  }
  async getResult() {
    return this.result;
  }
};
var YandexTrackerLinkerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.taskRegex = /@([A-Z]+-\d+)(?= )/g;
    // For existing tasks
    this.newTaskRegex = /(.*?)\s*@([A-Z]+)(?= )/;
    // Removed ^ to match anywhere in line
    this.isProcessing = false;
    this.linkRegex = /\[([A-Z]+-\d+)\]\(https?:\/\/[^\)]+\)/g;
  }
  async onload() {
    await this.loadSettings();
    console.log("YandexTrackerLinkerPlugin loaded.");
    this.addCommand({
      id: "convert-tracker-links",
      name: "Convert Tracker Links",
      editorCallback: (editor, view) => {
        this.processText(editor);
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const charBeforeCursor = cursor.ch > 0 ? line.charAt(cursor.ch - 1) : "";
        if (!this.isProcessing && charBeforeCursor === " ") {
          this.processText(editor);
        }
      })
    );
    this.addSettingTab(new YandexTrackerSettingTab(this.app, this));
  }
  onunload() {
    console.log("YandexTrackerLinkerPlugin unloaded.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async createTask(data) {
    try {
      const requestBody = {
        summary: data.summary,
        queue: {
          key: data.queueKey
        },
        description: data.description,
        deadline: data.deadline ? new Date(data.deadline).toISOString() : void 0,
        tags: data.tags
      };
      if (data.assignee) {
        requestBody.assignee = data.assignee;
      }
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://api.tracker.yandex.net/v2/issues/",
        method: "POST",
        headers: {
          "Authorization": `OAuth ${this.settings.apiToken}`,
          "X-Org-ID": this.settings.orgId,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.status !== 201) {
        throw new Error(`API request failed: ${response.status}`);
      }
      const responseData = Array.isArray(response.json) ? response.json[0] : response.json;
      if (!responseData || !responseData.key) {
        throw new Error("Invalid API response: missing task key");
      }
      return responseData.key;
    } catch (error) {
      console.error("Failed to create task:", error);
      if (error instanceof Error) {
        new import_obsidian.Notice(`Failed to create task: ${error.message}`);
      }
      throw error;
    }
  }
  cleanMarkdown(text) {
    return text.replace(/^\d+\.\s+/, "").replace(/^[-*+]\s+/, "").replace(/[*_]{1,3}([^*_]+)[*_]{1,3}/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/^>\s+/, "").replace(/<[^>]+>/g, "").trim();
  }
  async processText(editor) {
    if (this.isProcessing)
      return;
    this.isProcessing = true;
    const cursor = editor.getCursor();
    const content = editor.getValue();
    let updatedContent = content;
    try {
      const lines = content.split("\n");
      const currentLine = lines[cursor.line];
      const newTaskMatch = this.newTaskRegex.exec(currentLine);
      if (newTaskMatch && !currentLine.includes("](")) {
        const [fullMatch, taskSummary, queueKey] = newTaskMatch;
        if (this.settings.apiToken && this.settings.orgId) {
          try {
            const cleanSummary = this.cleanMarkdown(taskSummary || "");
            const summary = cleanSummary.trim() || "New task";
            const modal = new ConfirmationModal(this.app, summary, queueKey, this);
            modal.open();
            const result = await modal.getResult();
            if (!result.confirmed) {
              this.isProcessing = false;
              return;
            }
            const taskId = await this.createTask({
              summary: result.summary,
              queueKey,
              description: result.description,
              deadline: result.deadline,
              tags: result.tags,
              assignee: result.assignee
            });
            const newLine = currentLine.replace(
              fullMatch,
              `${taskSummary ? taskSummary + " " : ""}[${taskId}](${this.settings.trackerBaseURL}${taskId})`
            );
            lines[cursor.line] = newLine;
            updatedContent = lines.join("\n");
            new import_obsidian.Notice(`Task ${taskId} created successfully!`);
          } catch (error) {
            console.error("Failed to create task:", error);
            this.isProcessing = false;
            return;
          }
        } else {
          new import_obsidian.Notice("Please configure API Token and Organization ID in settings");
          this.isProcessing = false;
          return;
        }
      }
      updatedContent = updatedContent.replace(this.taskRegex, (fullMatch, taskId, offset) => {
        if (content.slice(Math.max(0, offset - 3), offset).endsWith("]("))
          return fullMatch;
        const lines2 = content.split("\n");
        const currentLineIndex = content.slice(0, offset).split("\n").length - 1;
        const currentLine2 = lines2[currentLineIndex];
        const urlPattern = new RegExp(`\\[${taskId}\\]\\(${this.settings.trackerBaseURL}${taskId}\\)`);
        if (urlPattern.test(currentLine2))
          return fullMatch;
        return `[${taskId}](${this.settings.trackerBaseURL}${taskId})`;
      });
      if (content !== updatedContent) {
        editor.setValue(updatedContent);
        editor.setCursor(cursor);
      }
    } finally {
      this.isProcessing = false;
    }
  }
};
var YandexTrackerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Tracker Base URL").setDesc("Base URL for Yandex Tracker").addText((text) => text.setPlaceholder("Enter base URL").setValue(this.plugin.settings.trackerBaseURL).onChange(async (value) => {
      this.plugin.settings.trackerBaseURL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Token").setDesc("OAuth token for Yandex Tracker API").addText((text) => text.setPlaceholder("Enter API token").setValue(this.plugin.settings.apiToken).onChange(async (value) => {
      this.plugin.settings.apiToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Organization ID").setDesc("Your Yandex Tracker organization ID").addText((text) => text.setPlaceholder("Enter org ID").setValue(this.plugin.settings.orgId).onChange(async (value) => {
      this.plugin.settings.orgId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Description").setDesc("Default description template for new tasks").addTextArea((text) => text.setValue(this.plugin.settings.defaultDescription).onChange(async (value) => {
      this.plugin.settings.defaultDescription = value;
      await this.plugin.saveSettings();
    })).setClass("yandex-tracker-description-setting");
    new import_obsidian.Setting(containerEl).setName("Default Assignees").setDesc("Comma-separated list of default assignee usernames for quick assignment").addText((text) => text.setPlaceholder("username1, username2, username3").setValue(this.plugin.settings.defaultAssignees.join(", ")).onChange(async (value) => {
      this.plugin.settings.defaultAssignees = value.split(",").map((username) => username.trim()).filter((username) => username.length > 0);
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("style", {
      text: `
                .yandex-tracker-description-setting textarea {
                    width: 100%;
                    height: 100px;
                    font-family: monospace;
                }
            `
    });
  }
};
